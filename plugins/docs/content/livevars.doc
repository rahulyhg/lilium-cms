<h2>Live Variables</h2>

<h3>In markup</h3>
<h4>Using parameters</h4>
<p>
	Live Variables can be integrated directly inside LML documents. They can be placed about anywhere within the body tag.
</p>
<p>
	The tags may contain various information about how the frontend framework will react to the Livevars tags. They can for instance return data from the server formatted as an Array and iterate inside a template, rendering it <b>n</b> times where <b>n</b> is the length of the returned Array.
</p>
<p>
	The syntax is pretty simple, and the output resembles plain HTML except the tags start with <b>lml</b>.
</p>
<pre>
	{*endpoint.all.simple(someparam:"somevalue",otherparam:"othervalue")}
</pre>	
<p>
	The anatomy is quite simple. Livevars identifier is an asterisk (<b>*</b>) followed by the endpoint and its levels split by dots (<b>.</b>). The Livevar may contain names parameters formatted as JSON using <b>key:value</b>. The parameters may be omitted in which case the parenthesis must be omitted as well. The output tag will contain non-HTML escaped characters like <b>&amp;lmlquote;</b> which are in fact normal quotation marks. 
</p>

<h4>Working with templates</h4>
<p>
	A template may be specified as a parameter. The template <i>key</i> represents the <b>HTML identifier</b> or an LML template tag. Those tags look like the following markup. 
</p>
<pre>
	{*endpoint.all(template:"myTemplate",target:"myContainer")}

	&lt;lml:template id="myTemplate" data-wrapper="div">
		&lt;lml:tobject data-nodetype="span" data-key="somelivevarkey">&lt;/lml:tobject>
	&lt;/lml:template>

	&lt;div id="myContainer">&lt;/div>
</pre>
<p>
	The previous snippet will receive data from the <code>endpoint.all</code> live variable endpoint, and will loop through the returned array, creating HTML nodes based on the <code>myTemplate</code> LML template. The created nodes will be copied inside the div with <code>myContainer</code> as an HTML identifier. 
</p>
<p>
	All livevars are grouped and a single request is done with all data requested. The returned values are contained inside the LML frontend wrapper, in the <code>livevars</code> Javascript Object. The property name is the complete endpoint including the levels. For instance, if a call is made to the live variable <code>endpoint.all.simple</code>, then the data will be contained inside <code>livevars["endpoint.all.simple"]</code>.
</p>

<h3>Inside a plugin</h3>
<p>
	Live Variables must be registered on the server before being served to the client. In order to do so, the live variable library must be included using <code>var livevars = require(pathToRoot + '/livevars.js');</code>. Once included, the <code>registerLiveVariable</code> function must be called along with 2 parameters. 
	<ul>
		<li>The desired endpoint name.</li>
		<li>
			The function called. Receives 4 parameters :
			<ul>
				<li>The client object.</li>
				<li>An array of levels.</li>
				<li>An object of parameters.</li>
				<li>A callback. Must be called passing returned data</li>
			</ul>
		</li>
	</ul>
</p>
<pre>
	var someData = {
		"foo" : "Hello, World!"
	};

	livevars.registerLiveVariable('endpoint', function(cli, levels, params, callback) {
		var firstLevel = levels[0];
		if (!firstLevel) {
			callback("[LiveVariableException] Endpoint must have at least one level.");
		} else if (typeof someData[firstLevel] === "undefined") {
			callback("[LiveVariableException] Unable to find data for level : " + firstLevel);
		} else {
			callback({
				data : someData[firstLevel]
			});
		}
	});
</pre>
<p>
	The previous endpoint will return the first level passed from the Object called <code>someData</code>. A working LML tag would be <code>{*endpoint.foo}</code>. 
</p>
